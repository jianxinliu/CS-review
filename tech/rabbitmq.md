# RabbitMQ 相关知识点

ref: [RabbitMQ](https://juejin.cn/post/6844904125935665160)

## MQ 的优点

1. 异步处理
2. 系统解耦。系统间通过队列通信，消息生产者不需要关系消费者是谁，消费情况如何、成功与否都由消费者自己保证，和生产者无关。
3. 流量削峰。可以通过控制队列长度控制请求量；利用队列作为缓冲，削平瞬时大量请求
4. 日志处理
5. 消息通讯

## RabbitMQ 基本概念

1. Broker: （代理）消息队列服务器实体
2. Exchange：消息交换机，指定消息按什么规则，路由到什么队列
3. Queue: 队列本身
4. Binding: 绑定，将 Exchange 和 Queue 按照路由规则绑定
5. Routing Key: 路由关键字，Exchange 据此进行消息投递

由 Exchange、Queue、Routing Key 三者确定一个从 Exchange到 Queue 的唯一路径

## 如何解决重复消费的问题

正常情况下，消费者消费消息后，会给 Queue 发送 ack 确认消费完成，但可能由于网路问题，ack 消息未送达，导致 Queue 再次将此消息发送至其他消费者，导致重复消费。

常见解决思路：

1. 保证消息的唯一性。给消息添加唯一标识，消费前进行判断，若已消费则丢弃。判断唯一性的方法可以利用数据库
2. 保证消费者的幂等性，消费相同的数据，不会系统或数据造成影响。

## 如何确保消息发送到了 MQ。如何确保消费者接收了消息。

### 发送方确认机制

将信道设置成 confirm 模式（发送方确认模式），所有在信道上发布的消息都会被指派一个唯一的 ID，一旦消息被投入指定队列之后，信道会发送一个确认消息给发送方；如果未成功投入信道，则会发送 Nack 消息给发送方。

### 接受方确认机制

消费者对每一条消息的接收都必须进行确认，只有消费者确认了，MQ 才会将此信息从 Queue 中删除。RabbitMQ 仅仅通过消费者的连接状态来确定是否需要重新发送消息。也就是说，只要连接不中断，MQ 会认为消费者繁忙，将不会重发消息，保证数据的最终一致性。

## 如何保证 RabbitMQ 消息的可靠传输

消息不可靠的情况可能是消息丢失、消息劫持等原因。

消息丢失又分为：生产者丢失消息、队列丢失消息、消费者丢失消息

### 生产者丢消息

RabbitMQ 提供 transaction 和 confirm 模式确保生产者不丢消息。

1. transaction 事务，发消息前开启事务，若发消息过程中出现异常，事务会回滚；若发送成功则事务提交。改模式会导致吞吐量下降
2. confirm 模式使用居多。如上文所述，消息未成功进入队列，会返回生产者 Nack 消息，生产者可以重试。

### 队列丢消息

RabbitMQ 使用消息持久化来应对队列丢消息。持久化可以和 confirm 机制配合，队列持久化之后再给生产者发送 ack 消息。

持久化步骤：

1. 将 Queue 的持久化标识 durable 设置为 true
2. 发送消息时，将 deliveryMode 设置为 2

设置持久化后，即使 MQ 挂了，重启后也能恢复数据

### 消费者丢消息
 
消费者丢消息一般是因为采用了自动确认机制，改为手动确认即可。